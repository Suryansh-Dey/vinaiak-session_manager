use super::request::*;
use derive_new::new;
use serde::{Deserialize, Serialize};
use serde_json::Value;

#[derive(Serialize, Deserialize)]
#[allow(non_camel_case_types)]
pub enum FinishReason {
    /// Default value. This value is unused.
    FINISH_REASON_UNSPECIFIED,
    /// Natural stop point of the model or provided stop sequence.
    STOP,
    /// The maximum number of tokens as specified in the request was reached.
    MAX_TOKENS,
    /// The response candidate content was flagged for safety reasons.
    SAFETY,
    /// The response candidate content was flagged for recitation reasons.
    RECITATION,
    /// The response candidate content was flagged for using an unsupported language.
    LANGUAGE,
    /// Unknown reason.
    OTHER,
    /// Token generation stopped because the content contains forbidden terms.
    BLOCKLIST,
    /// Token generation stopped for potentially containing prohibited content.
    PROHIBITED_CONTENT,
    /// Token generation stopped because the content potentially contains Sensitive Personally Identifiable Information (SPII).
    SPII,
    /// The function call generated by the model is invalid.
    MALFORMED_FUNCTION_CALL,
    /// Token generation stopped because generated images contain safety violations.
    IMAGE_SAFETY,
}

#[derive(Serialize, Deserialize, new)]
#[allow(non_snake_case)]
struct Candidate {
    content: Chat,
    pub finishReason: Option<FinishReason>,
}

#[derive(Serialize, Deserialize)]
#[allow(non_snake_case)]
pub struct GeminiResponse {
    candidates: Vec<Candidate>,
    pub usageMetadata: Value,
    pub modelVersion: String,
    pub promptFeedback: Option<Value>,
}
impl GeminiResponse {
    pub fn from_str(string: impl AsRef<str>) -> Result<Self, serde_json::Error> {
        serde_json::from_str(string.as_ref())
    }
    pub fn get_parts(&self) -> &Vec<Part> {
        self.candidates[0].content.parts()
    }
    pub fn get_json<T>(&self) -> Result<T, serde_json::Error>
    where
        T: serde::de::DeserializeOwned,
    {
        let unescaped_str = self.get_text("").replace("\\\"", "\"").replace("\\n", "\n");
        serde_json::from_str::<T>(&unescaped_str)
    }
    pub fn parse_json<T>(parts: &[Part]) -> Result<T, serde_json::Error>
    where
        T: serde::de::DeserializeOwned,
    {
        let unescaped_str = Self::extract_text(parts, "")
            .replace("\\\"", "\"")
            .replace("\\n", "\n");
        serde_json::from_str::<T>(&unescaped_str)
    }
    ///`seperator` used to concatenate all text parts. TL;DR use "" as seperator.
    pub fn extract_text(parts: &[Part], seperator: impl AsRef<str>) -> String {
        let mut concatenated_string = String::new();
        for part in parts {
            if let Part::text(text) = part {
                concatenated_string.push_str(text);
                concatenated_string.push_str(seperator.as_ref());
            }
        }
        concatenated_string
    }
    ///`seperator` used to concatenate all text parts. TL;DR use "" as seperator.
    pub fn get_text(&self, seperator: impl AsRef<str>) -> String {
        Self::extract_text(&self.get_parts(), seperator.as_ref())
    }
}
